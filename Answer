## ANSWER

### BEGIN
这里有一个trick对2的整数冥取余就是与`2^n-1`

```
void dec2bin(int x) 
{
    if (x){
        printf("%d", x & 1);
        dec2bin(x >> 2);
    }
}
```
递归版本的简单易于理解，但是有函数调用开销。迭代版本的由你们自己写吧。
这里并没有要求存到什么样的数据结构中，我的推荐是位向量。关于位向量又有很多程序需要注意，还有要用各种2进制的特性啊！对于2, 4, 8, 这种东西应该用移位啊！关于转二进制的算法我目前就知道除K取余法，我在这里想考察的是，是否知道递归可以被转换为迭代的概念。即一个递归版本，一个迭代版本。

### 1
这一题就是考察是否理解表达式与语句的概念。前一个是语句，没有被求值也就是说不能出现在赋值号的右边。而后一个是表达式，表达式都会被求值。这也是为什么
诸如`while((c = getchar()) ！= EOF)`这样的语句存在的原因。赋值在C中也是表达式。在不同的范式中，这两个概念是很重要的，如果听说过函数式编程，那么基本上所有程序片段都是表达式，一值不停的求值，过程式中，语句的形式更易于理解。

### 2
这一题考察优先级，结合性的知识，说实话，我也记不住很烦索的例子。只需要记住几个trick就好，`()`最大，能最优先改变运算顺序，赋值比其他运算符优先级都低，除了`,`所以如果赋值出现在表达式里，我都会加个括号。在自己不清楚几个运算符优先级的情况下`加括号`是最好的办法。不会有任何效率什么的影响。这类问题其实都不是由程序员引起的，是由语言本身决定的。这个问题提出实际上是让大家注意要有编码风格，好的编码风格能大大降低此类问题的发生。

### 3
这是个大问题，但问这个问题的目的是考察大家是否知道`程序`的真正意义。是什么促成了计算机科学。你对自己所学的专业有认真思考过吗？这个问题在C语言教科书的开篇就讲了。当时我的做法是背下来应付考试。直到我大二第二学期看了一本书《程序员的自我修养》我才对这个问题有了自己的理解。现在来说答案。
比较通识的是`编译`。CPU是不知道你在c-soure-file的任何一个字的。它只知道0,1。这里的EXE文件即二进制文件，暂且认为计算机能读懂它。而编译的目的是将ASCII文件翻译成二进制文件。对于每一种语言来说，它又有自己的特性。比如C它先是预处理，就是简单粗暴的把文件内容，或者字符内容复制粘贴。然后是编译成obj文件。也是一种二进制文件，这种文件里并没有关于全局变量的地址信息。链接阶段，链接器把许多obj文件链接起来，组成一个可执行文件。链接器做的工作是把未定位的符号全部重定位。最后操作系统把可执行文件装载到内存中，程序开始执行。
由于C的语言特性，与硬件结合极为紧密。理解上述过程，对于操作系统，编译原理等课有莫大的帮助。这方面的知识，可看我上面提到的那本书。

### 4
这段程序分配了5字节。这段程序意在考察，声明，定义的概念。首先明确一个观点。任何声明都是不占内存的。所以typedef 啊，声明一个结构体类型都是不占内存的。只有对变量的定义才会分配内存。也就是位段`struct {unsigned:4; unsigned:4;} i;`。占1个字节，extern 也是一种声明，而这个全局变量在别的文件中定义。最后一个定义一个指针，无论指向什么都是4字节。这些都是基础啊！通过这道题告诉我们，基础很重要，基础掌握的好，才不会被各种复杂的表达式眩晕。

### 5
while 那行确实是少了右括号，笔误...
这段程序就是统计文件中的字符数，行数，和以空格分隔的单词数。我还是看到了改进的时候，有个同学加了break...说明你没有理解switch语句的真正含义，switch语句匹配成功时就会从这个入口一直执行下去，而不是跳出来。 通常程序中加break，是为了执行完那一条就跳出来。这里并不需要。而真正不妥之处，我认为是程序打开文件后竟然没有检查，文件的指针的合法性！写程序不做错误处理本身就是一种错误。即使这种错误的概率很小，我们说程序的健壮性，都是通过这样的细节来填充的。

### 6
```
void copy(int const * src, int * dst, int size)
{
    int *end = src + (size - 1);
    for (; src < end; src++, end++) {
        *dst = *src;
    }
}
```
有很多人写的关键代码如下
```
dst[i] = src[i]
```
下标的代价也是很大的。因为计算偏移时是有乘法指令的。具体的可以看我写过的一篇博客。[指针](https://github.com/whps/whps.github.io/issues/7)。程序员
高下之差。 恐怕就是对这样的问题研究程度了，时常想一想怎样让程序效率更高是不错的习惯。

### 7
开篇讲了一个trick，所以这句话现在可以看成这样。
putchar("0123456789ABCDEF"[value % 16]);又有一处笔误不好意思...应该是0xF。所以这条语句就是对value取16的余然后打印出来对应的十六进制表示。之所以可行是因为，在C中字符串常量是指针常量类型，所以可以按照访问指针的形式来访问它。不要刻意追求这样的语句。通常都是投机取巧，作为了解即可。

### 9
给出程序如下
```
struct {
    unsigned a: 4;
    unsigned b: 4;
} i;
for (i.a = 1; i.a <= 9; i.a++) {
    for (i.b = 1; i.b <= 9; i.b++) {
        if ((i.a % 3) != (i.b % 3)) printf("(%d, %d)", i.a, i.b); 
    }
}
```
我以前在学习的过程中通常会想，学这个有什么用，干脆跳过吧。这个例子告诉我们位段也是很有用的。这道题实际上就是想表达 9+9 = 18 种信息对于C提供的数据类型，我们可以用一个字节来表示。所以，学习的过程不是以个人的意志为主导的，如果一开始态度不端正。那么知识也就离你远去了。当然，不是说，非要搞清每一个细节，每一处难以理解的trick，要分辨轻重，随着知识系统的建立，这种辨识度也会提高。

### 10

### END
C语言最酷旋的特性当然是指针啊。
```
简单来说，因为C就那点破feature，如果你把指针干掉，那这语言就完了。相反，如果你干掉struct，干掉union，干掉数组，甚至你把if-while都干掉，留下malloc和goto，则最多就是程序难写一点而已。所以这就是为什么C语言的精髓是指针了，因为他只有指针可以用了。
```
祝各位同学写得一手好代码。
